@doc """
For imaginary-time/-frequency domains
"""
struct ImaginaryTimeFT <: AbstractFT
    ftcore::FTCore

    function ImaginaryTimeFT(ftcore::FTCore)
        new(ftcore)
    end
end

#function to_wn(::Fermionic, gtau::MPS, beta::Float64, tag::String="τ"; nbit=length(gtau), kwargs...)
    #sites = 
#end

function to_wn(::Fermionic, ft::ImaginaryTimeFT, gtau::MPS, beta::Float64; kwargs...)
    length(gtau) == nbit(ft) || error("Length mismatch")
    nbit_ = length(gtau)
    gtau = noprime(copy(gtau))

    N = 2^nbit_
    sites = siteinds(gtau)

    # Apply phase shift to each Qubit
    θ = π * ((-N+1)/N)
    for i in 1:nbit_
        gtau[i] = noprime(gtau[i] * op("Phase", sites[i]; ϕ= θ * 2^(nbit_-i) ))
    end

    # FFT
    M = forwardmpo(ft.ftcore, sites)
    giv = ITensors.apply(M, gtau; kwargs...)
    giv *= beta * 2^(-nbit_/2)

    return giv
end


function to_tau(::Fermionic, ft::ImaginaryTimeFT, giv::MPS, beta::Float64; kwargs...)
    length(giv) == nbit(ft) || error("Length mismatch")
    nbit_ = length(giv)
    giv = noprime(copy(giv))

    N = 2^nbit_
    sites = siteinds(giv)

    # Inverse FFT
    M = backwardmpo(ft.ftcore, sites)

    gtau = ITensors.apply(M, giv; kwargs...)

    gtau *= (2^(nbit_/2))/beta

    # Apply phase shift
    θ = - π * ((-N+1)/N)
    for i in 1:nbit_
        gtau[i] = noprime(gtau[i] * op("Phase", sites[i]; ϕ= θ * 2^(nbit_-i) ))
    end

    return gtau
end


function decompose_gtau(gtau_smpl::Vector{ComplexF64}, sites; kwargs...)
    nbit = length(sites)
    length(gtau_smpl) == 2^nbit || error("Length mismatch")

    # (g_1, g_2, ...)
    gtau_smpl = reshape(gtau_smpl, repeat([2,], nbit)...)
    gtau_smpl = permutedims(gtau_smpl, reverse(collect(1:nbit)))

    return MPS(gtau_smpl, sites; kwargs...)
end


function decompose_giv(giv_smpl::Vector{ComplexF64}, sites; kwargs...)
    nbit = length(sites)
    length(giv_smpl) == 2^nbit || error("Length mismatch")

    # (g_N, g_{N-1}, ...)
    giv_smpl = reshape(giv_smpl, repeat([2,], nbit)...)

    return MPS(giv_smpl, sites; kwargs...)
end


"""
Construct an MPS representing G(τ) generated by a pole
"""
function poletomps(sites, β, ω)
    nqubits = length(sites)
    links = [Index(1, "Link,l=$l") for l in 0:nqubits]
    tensors = ITensor[]
    for n in 1:nqubits
        push!(tensors, ITensor([1.0, exp(-(0.5^n) * β * ω)], links[n], links[n+1], sites[n]))
    end
    tensors[1] *= -1/(1 + exp(-β * ω))
    tensors[1] *= onehot(links[1]=>1)
    tensors[end] *= onehot(links[end]=>1)
    return MPS(tensors)
end